## Hashed Files

一級：快取、緩存
二級：硬碟、CD
三級：磁帶、黑膠唱片


#### 英文小教室
| English | 中文 | 備註 |
| :---: | :---: | :---: |
| nonvolatile | 非揮發性 | |
| accesse | 訪問 | |
| auxiliary | 輔助的 | |
| be used for | 已用於 | |
| magnetic | 磁盤 | |
| capacity | 容量 | |
| rotating | 旋轉 | |
| spindle | 主軸 | |
| divided into | 分成 | |
| concentric | 同心 | |
| track | 軌道 | |





#### Primary Index
建立在有排序的檔案
ordering key 一個欄位
#### Clustering Index
建立在有排序的檔案
ordering nonkey 一個欄位  可能是多值
#### Secondary Index
任何資料都可以，無須排序
欄位可以建立在沒有排序的欄位，且有可能是 key 或 nonkey
所以他可以建立多個欄位的

#### Primary Index
定義在檔案有排序的情況下
才在是 key 的欄位下
nondense
這樣每一個 block 就都可以用 Index 去尋找
搜尋到的資料會在該表的第一個 row
called **block anchor**
取上值
ex 搜尋 Abbot
他在前兩項中間，所以他會去搜尋上一個 row，會在她裡面
![[Pasted image 20221229084507.png]]
會比較少 index entries ( 索引數量 )

bfr 一個 block 可以放 file 的數量 = 下高斯( B/R ) blocksize / record length
b 多少 block = 上高斯( r/bfr ) all of file / bfr
bfri 一個 block 可以放的 index 數量 = 下高斯( B/R_i ) blocksize / ( key + block pointer )
bi 總共放index的block的數量 = 上高斯( r_i/bfri )

##### Problem
+ 插入資料不夠時
	+ 給定多一點的欄位數量，overflow file給他
	+ 用 linked list
+ 若要刪除就標記就好，不用直接刪

#### Clustering Index
檔案也需要排序過
使用 non-key，會有重複的值
nondense
用重複的東西來做分群
找到的index會是分群的第一個資料的那群，但她不一定是那個分群的資料，下圖舉例
![[Pasted image 20221229085844.png]]
變種的資料儲存方式，就可以讓bolck都是同一個index的值，插入時也會更好插，算是用hash value來搜尋
![[Pasted image 20221229090232.png]]

#### Secondary Index
有無排序都可以
可以是 key 或 nonkey

會把index 是排序
可以用 block pointer 或 record pointer
每一個key都有對應的，所以是dense

需要比較多的空間跟時間
但改進比較好，因為他不需要linear的搜尋，無須排序

當nonkey時
+ dense
+ nondense，同一個指標放在一起，每一個指標都有一block
+ nondense，給一個額外的block放指標，然後再去對應真正的block，下圖舉例，會多讀一個block
	![[Pasted image 20221229092938.png]]
Secondary 以上提供邏輯上的排序基於index

#### Summary

![[Pasted image 20221229093403.png]]

#### How to Create an Index
```sql
CREATE [ UNIQUE ] INDEX <index name>
ON     <table name> ( <colume name> [ <order> ]
{ , <colume name> [ <order> ]} )
[ CLUSTER ]
```
建立一個分群 index
![[Pasted image 20221229093837.png]]
會根據Dno去做分群

#### Multi-Level Indexes
以上描述是 single-level index，所以 index 對到的東西一定是 Primary index，所以後面都會是 Primary index 分類

且整體搜尋會是 log_fo，因為每一層都剪掉一個 fo，fo = bfri

r1 = 會是所有個block的數量
r2 = r1會對到幾個block的數量
.
.
.
r_n = r_n-1會對到幾個block的數量
且去上高斯

然後總數最後要加上1，因為要多一個存資料的

所帶來的代價是
當資料有更新或是新增的時候，DBMS需要去更新很多東西


#### RAID
為一個 disk striping
降低冗餘的資訊
有很多個level

#### Storage Area Networks
管資料的成本會比儲存的設備的成本低