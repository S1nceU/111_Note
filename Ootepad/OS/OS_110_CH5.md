## Basic Concepts
+ 為什麼要 scheduling，因為有 multiprogramming
+ **CPU-I/O burst cycle** : 一連串的執行是做什麼，就是甚麼 burst
	+ 一連串長時間的 CPU 執行，就為 **CPU burst**
	+ 通常會有
		+ 大數量的短 CPU burst
		+ 少數量的長 CPU burst
#### CPU - I/O Burst Cycle
+ 大部分的 CPU burst 時長都非常短

#### CPU Scheduler
選擇 ready queue 裡面，誰先要執行

#### Preemptive vs. Non-preemptive
+ 可以做 scheduler 的時間點
	+ **running to waiting** ：在做 I/O，scheduler 就可以安排下一個
	+ running to ready：Time sharing
	+ waiting to ready：I/O 做完了，看要不要幫 process 插隊
	+ **Terminates**

+ Non-preemptive
	+ 不打斷其他 process 的執行，要等別人做完，所以只有上述的 1 跟 4
+ Preemptive 
	+ 會打斷別人，所以上述都會

#### Preemptive Issue
+ 效能通常比較好
+ 讓 CPU 的使用率比較高

+ require process synchronization 需要同步進程

+ Affect the design of **OS kernel**
	+ 在 Kernel 裡面解決同步問題
	+ 禁用 interrupt，就像是換成了 Non-preemptive 一樣，再也不會打斷其他 process

#### Dispatcher ( 知道就好瞜 )
+ 執行換人的動作
+ example
	+ switch context
	+ jumping to the proper location in the selected program
+ Dispatch latency 調度延遲
	+ Scheduling time 
	+ Interrupt re-enabling time 
	+ Context switch time

## Scheduling Algorithms
#### Scheduling Criteria
**以系統的角度**
+ CPU utilization
	+ 理論上： 0% ~ 100%
	+ 實際上：40% ~ 90%
+ Throughput
	+ 每單位時間內平均完成 processes 的工作量
**以單一 process 的角度**
+ Turnaround time 
	+  一個 process 從進程到完成要多久的時間
	+ submission ~ completion
+ Waiting time 
	+ 在 ready queue 裡面要等多久時間結束
	+ 完成時間 - 自己執行時間 - 抵達的時間
+ Response time
	+ submission ~ first reponse 
	+ 進去到開始執行的時間
	+ 開始 - 抵達

#### FCFS Scheduling
+ 先進先服務
+ Convoy effect：有可能會有 short process 要等前面的 long process
	+ 順序就是要看運氣

#### Shortest-Job-First ( SJF ) Scheduling
+ 讓最短的先服務
+ 可以能會有兩種可能
	+ Non-preemptive
	+ preemptive

#### Approxiamte SJF 近似 SJF
+ SJF 很難實現
+ 所以用預測的方式，exponential average
	+ $T_{n+1} = a\,t_n\,(1-a)\,T_n$ ：$t_n$ is new one , $T_n$ is history
	+ Commonly a = 1/2，兩個的平均

#### Priority Scheduling
+ 靠著當下的優先度，決定誰要執行
+ 也有問題
	+ Preemptive
	+ Non-preemptive

+ 會有 Starvation，就是優先度太低，可能永遠執行不到
	+ Sol: **aging** 在一段時間，增加未執行的優先度






## Special Scheduling Issues

## Scheduling Case Study
