## Background 

+ 唯一 CPU 可以直接 access 
+ 把很多 porcess 放在 memory 
+ moved between disk and memory

#### User Program in Multi step
+ Compiler > linkage > loader

#### Address Binding ( How to refer memory in a program ? )
##### Compile Time
+ 決定變數和程式碼的位址在哪裡
+ 編譯成組合語言 **absolute code**
+ 搬運程式就必須 recompiler

##### Load Time
+ 可以 relocatable code，可以將程式搬運到空的空間，非固定的空間
+ 但要搬運記憶體，還是得 recompiler

##### Execution Time
+ 是邏輯位置，不是實體位置
+ 會再傳到 CPU 前，會經過 MMU 轉錄程式碼


###### MMU ( Memory-Management Unit )
+ 硬體實作的
+ 映射虛擬位置到實體位置
+ 重新定位暫存器的位址

#### Logical vs. Physical Address
+ Logical address : 從 CPU 送出來的
	+ a.k.a. **virtual address**
+ Physical address : **Memory module**
+ compile time & load time address binding 
	+ L = P
+ Execution-time address binding
	+ L != P
+ 使用者處理的是 L ，從不會看到真實的 P

#### Static/dynamic loading and linking ( How to load a program into memory ? )
##### Dynamic Loading
+ 動態分配記憶體，當被呼叫的時候
+ 更好的記憶體運用
	+ 從不載入未使用的例程
	+ 當大量代碼不經常使用特定用處，也不載入
+ 沒有特別 OS 輔助
+ 簡單來說，呼叫的時候出現就好，結束了就會被踢走

##### Static Linking 


## Swapping
## Contiguous Allocation
## Paging
## Segmentation
## Segmentation with Paging