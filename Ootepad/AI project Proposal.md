	一開始面對題目的時候，心中冒出的答案直覺是用貪婪演算法（Greedy search algorithm），所以只寫了周遭八個方位的點只要離終點最近且不會碰到障礙物做判斷。而最終在 small-easy 上測試結果時，成功呈現了到終點最短路徑的呈現。
	但其中就會有一個淺在的問題，甚至對後面的開發影響其深。在我們測試 small-medium 時，出現了走到死路的情況，而且我們看了結果發現，路徑規劃時，居然在兩個點重複徘徊。此問題的發生原因，是在遇到該路徑的方向雖然的確是往終點最近的方向前進，但走到底之後，會發現因為會為了繼續往終點方向走，但中間有障礙物，路徑的規劃會被障礙物擋住，所以會在除了自己以外離終點最近的點鐘間無限徘徊，而造成像是死路的路線出現。
	而為了解決以上的問題，我們嘗試了很多的判斷，像是做回頭的其他方向、不走同一條路徑、同一個點的不重複......，試過了很多的方法，結果發現自己的程式有許多的漏洞，而造成漏洞越修越多，需要思考的面向也變得太思考，導致我們不管怎麼修復以及加進新的判斷思維，在我們目前的能力範圍可能無法修好我們原本的程式碼，所以最後我們決定改變我們最佳路徑的演算法，改使用A*搜尋演算法去實作這次的專案。